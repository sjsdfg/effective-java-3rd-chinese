## ✏️ CS-Notes-PDF

- [CS-Notes-PDF](https://github.com/sjsdfg/CS-Notes-PDF) 

## 📚 高效 Java 第三版


### Chapter 2. Creating and Destroying Objects

- [01. 考虑使用静态工厂方法替代构造方法](notes/01.%20考虑使用静态工厂方法替代构造方法.md)
- [02. 当构造方法参数过多时使用builder模式](notes/02.%20当构造方法参数过多时使用builder模式.md)
- [03. 使用私有构造方法或枚类实现Singleton属性](notes/03.%20使用私有构造方法或枚类实现Singleton属性.md)
- [04. 使用私有构造方法执行非实例化](notes/04.%20使用私有构造方法执行非实例化.md)
- [05. 依赖注入优于硬连接资源(hardwiring resources)](notes/05.%20依赖注入优于硬连接资源(hardwiring%20resources).md)
- [06. 避免创建不必要的对象](notes/06.%20避免创建不必要的对象.md)
- [07. 消除过期的对象引用](notes/07.%20消除过期的对象引用.md)
- [08. 避免使用Finalizer和Cleaner机制](notes/08.%20避免使用Finalizer和Cleaner机制.md)

### Chapter 3. Methods Common to All Objects

- [09. 使用try-with-resources语句替代try-finally语句](notes/09.%20使用try-with-resources语句替代try-finally语句.md)
- [10. 重写equals方法时遵守通用约定](notes/10.%20重写equals方法时遵守通用约定.md)
- [11. 重写equals方法时同时也要重写hashcode方法](notes/11.%20重写equals方法时同时也要重写hashcode方法.md)
- [12. 始终重写 toString 方法](notes/12.%20始终重写%20toString%20方法.md)
- [13. 谨慎地重写 clone 方法](notes/13.%20谨慎地重写%20clone%20方法.md)
- [14. 考虑实现Comparable接口](notes/14.%20考虑实现Comparable接口.md)

### Chapter 4. Classes and Interfaces

- [15. 使类和成员的可访问性最小化](notes/15.%20使类和成员的可访问性最小化.md)
- [16. 在公共类中使用访问方法而不是公共属性](notes/16.%20在公共类中使用访问方法而不是公共属性.md)
- [17. 最小化可变性](notes/17.%20最小化可变性.md)
- [18. 组合优于继承](notes/18.%20组合优于继承.md)
- [19. 要么设计继承并提供文档说明，要么禁用继承](notes/19.%20要么设计继承并提供文档说明，要么禁用继承.md)
- [20. 接口优于抽象类](notes/20.%20接口优于抽象类.md)
- [21. 为后代设计接口](notes/21.%20为后代设计接口.md)
- [22. 接口仅用来定义类型](notes/22.%20接口仅用来定义类型.md)
- [23. 类层次结构优于标签类](notes/23.%20类层次结构优于标签类.md)
- [24. 支持使用静态成员类而不是非静态类](notes/24.%20支持使用静态成员类而不是非静态类.md)
- [25. 将源文件限制为单个顶级类](notes/25.%20将源文件限制为单个顶级类.md)

### Chapter 5. Generics

- [26. 不要使用原始类型](notes/26.%20不要使用原始类型.md)
- [27. 消除非检查警告](notes/27.%20消除非检查警告.md)
- [28. 列表优于数组](notes/28.%20列表优于数组.md)
- [29. 优先考虑泛型](notes/29.%20优先考虑泛型.md)
- [30. 优先使用泛型方法](notes/30.%20优先使用泛型方法.md)
- [31. 使用限定通配符来增加API的灵活性](notes/31.%20使用限定通配符来增加API的灵活性.md)
- [32. 合理地结合泛型和可变参数](notes/32.%20合理地结合泛型和可变参数.md)
- [33. 优先考虑类型安全的异构容器](notes/33.%20优先考虑类型安全的异构容器.md)

### Chapter 6. Enums and Annotations

- [34. 使用枚举类型替代整型常量](notes/34.%20使用枚举类型替代整型常量.md)
- [35. 使用实例属性替代序数](notes/35.%20使用实例属性替代序数.md)
- [36. 使用EnumSet替代位属性](notes/36.%20使用EnumSet替代位属性.md)
- [37. 使用EnumMap替代序数索引](notes/37.%20使用EnumMap替代序数索引.md)
- [38. 使用接口模拟可扩展的枚举](notes/38.%20使用接口模拟可扩展的枚举.md)
- [39. 注解优于命名模式](notes/39.%20注解优于命名模式.md)
- [40. 始终使用Override注解](notes/40.%20始终使用Override注解.md)
- [41. 使用标记接口定义类型](notes/41.%20使用标记接口定义类型.md)

### Chapter 7. Lambdas and Streams

- [42. lambda表达式优于匿名类](notes/42.%20lambda表达式优于匿名类.md)
- [43. 方法引用优于lambda表达式](notes/43.%20方法引用优于lambda表达式.md)
- [44. 优先使用标准的函数式接口](notes/44.%20优先使用标准的函数式接口.md)
- [45. 明智审慎地使用Stream](notes/45.%20明智审慎地使用Stream.md)
- [46. 优先考虑流中无副作用的函数](notes/46.%20优先考虑流中无副作用的函数.md)
- [47. 优先使用Collection而不是Stream来作为方法的返回类型](notes/47.%20优先使用Collection而不是Stream来作为方法的返回类型.md)
- [48. 谨慎使用流并行](notes/48.%20谨慎使用流并行.md)

### Chapter 8. Methods

- [49. 检查参数有效性](notes/49.%20检查参数有效性.md)
- [50. 必要时进行防御性拷贝](notes/50.%20必要时进行防御性拷贝.md)
- [51. 仔细设计方法签名](notes/51.%20仔细设计方法签名.md)
- [52. 明智审慎地使用重载](notes/52.%20明智审慎地使用重载.md)
- [53. 明智审慎地使用可变参数](notes/53.%20明智审慎地使用可变参数.md)
- [54. 返回空的数组或集合，不要返回 null](notes/54.%20返回空的数组或集合，不要返回%20null.md)
- [55. 明智审慎地返回 Optional](notes/55.%20明智审慎地返回%20Optional.md)
- [56. 为所有已公开的 API 元素编写文档注释](notes/56.%20为所有已公开的%20API%20元素编写文档注释.md)

### Chapter 9. General Programming

- [57. 最小化局部变量的作用域](notes/57.%20最小化局部变量的作用域.md)
- [58. for-each 循环优于传统 for 循环](notes/58.%20for-each%20循环优于传统%20for%20循环.md)
- [59. 了解并使用库](notes/59.%20了解并使用库.md)
- [60. 若需要精确答案就应避免使用 float 和 double 类型](notes/60.%20若需要精确答案就应避免使用%20float%20和%20double%20类型.md)
- [61. 基本数据类型优于包装类](notes/61.%20基本数据类型优于包装类.md)
- [62. 当使用其他类型更合适时应避免使用字符串](notes/62.%20当使用其他类型更合适时应避免使用字符串.md)
- [63. 当心字符串连接引起的性能问题](notes/63.%20当心字符串连接引起的性能问题.md)
- [64. 通过接口引用对象](notes/64.%20通过接口引用对象.md)
- [65. 接口优于反射](notes/65.%20接口优于反射.md)
- [66. 明智审慎地本地方法](notes/66.%20明智审慎地本地方法.md)
- [67. 明智审慎地进行优化](notes/67.%20明智审慎地进行优化.md)
- [68. 遵守被广泛认可的命名约定](notes/68.%20遵守被广泛认可的命名约定.md)

### Chapter 10. Exceptions

- [69. 只针对异常的情况下才使用异常](notes/69.%20只针对异常的情况下才使用异常.md)
- [70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常](notes/70.%20对可恢复的情况使用受检异常，对编程错误使用运行时异常.md)
- [71. 避免不必要的使用受检异常](notes/71.%20避免不必要的使用受检异常.md)
- [72. 优先使用标准的异常](notes/72.%20优先使用标准的异常.md)
- [73. 抛出与抽象对应的异常](notes/73.%20抛出与抽象对应的异常.md)
- [74. 每个方法抛出的异常都需要创建文档](notes/74.%20每个方法抛出的异常都需要创建文档.md)
- [75. 在细节消息中包含失败一捕获信息](notes/75.%20在细节消息中包含失败一捕获信息.md)
- [76. 保持失败原子性](notes/76.%20保持失败原子性.md)
- [77. 不要忽略异常](notes/77.%20不要忽略异常.md)

### Chapter 11. Concurrency

- [78. 同步访问共享的可变数据](notes/78.%20同步访问共享的可变数据.md)
- [79. 避免过度同步](notes/79.%20避免过度同步.md)
- [80. executor 、task 和 stream 优先于线程](notes/80.%20executor%20、task%20和%20stream%20优先于线程.md)
- [81. 并发工具优于 wait 和 notify](notes/81.%20并发工具优于%20wait%20和%20notify.md)
- [82. 文档应包含线程安全属性](notes/82.%20文档应包含线程安全属性.md)
- [83. 明智审慎的使用延迟初始化](notes/83.%20明智审慎的使用延迟初始化.md)
- [84. 不要依赖线程调度器](notes/84.%20不要依赖线程调度器.md)

### Chapter 12. Serialization

- [85. 优先选择 Java 序列化的替代方案](notes/85.%20优先选择%20Java%20序列化的替代方案.md)
- [86. 非常谨慎地实现 Serializable](notes/86.%20非常谨慎地实现%20Serializable.md)
- [87. 考虑使用自定义的序列化形式](notes/87.%20考虑使用自定义的序列化形式.md)
- [88. 保护性的编写 readObject 方法](notes/88.%20保护性的编写%20readObject%20方法.md)
- [89. 对于实例控制，枚举类型优于 readResolve](notes/89.%20对于实例控制，枚举类型优于%20readResolve.md)
- [90. 考虑用序列化代理代替序列化实例](notes/90.%20考虑用序列化代理代替序列化实例.md)